<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chat de classe</title>
<style>
  :root{
    --bg:linear-gradient(135deg,#6a11cb,#2575fc);
    --card:rgba(255,255,255,0.04);
    --muted:rgba(238,242,255,0.8);
    --primary:linear-gradient(90deg,#7f5af0,#6a11cb);
    --radius:12px;font-family:Inter,Arial,sans-serif;
  }
  body{margin:0;min-height:100vh;background:var(--bg);color:#eef2ff}
  .wrap{max-width:1100px;margin:18px auto;padding:16px}
  .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0}
  .card{background:var(--card);padding:16px;border-radius:var(--radius)}
  .layout{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
  .left{flex:1;min-width:300px}
  .right{width:300px;min-width:220px}
  .messages{overflow-y:auto;max-height:420px;padding:12px;display:flex;flex-direction:column;gap:10px;border-radius:10px;background:rgba(0,0,0,0.06)}
  .msg{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02)}
  .meta{font-size:13px;color:var(--muted);margin-bottom:6px}
  .composer{display:flex;gap:8px;margin-top:12px}
  .input{flex:1;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .btn{padding:10px 14px;border-radius:10px;border:none;background:var(--primary);color:white;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .members{padding:10px;border-radius:10px;background:rgba(0,0,0,0.04);max-height:420px;overflow:auto}
  .notice{padding:10px;border-radius:8px;background:rgba(255,205,87,0.08);color:#fff7e6;margin-top:8px}
  .small{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Chat de classe</h1>
        <div id="sub" class="small">Chargement…</div>
      </div>
      <div>
        <button class="btn ghost" onclick="location.href='home.html'">← Retour</button>
      </div>
    </div>

    <div class="card">
      <div class="layout">
        <div class="left">
          <div id="welcome" class="meta">Chargement du chat…</div>
          <div id="messages" class="messages" aria-live="polite"></div>

          <div id="composerWrap" class="composer" style="display:none">
            <input id="textInput" class="input" placeholder="Écris ton message... (Enter pour envoyer)"/>
            <button id="sendBtn" class="btn">Envoyer</button>
          </div>

          <div id="cantWrite" class="notice" style="display:none">Tu n'appartiens pas à cette classe — écriture désactivée.</div>
        </div>

        <div class="right">
          <div><strong>Membres</strong></div>
          <div id="members" class="members">Chargement...</div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
/* classe.html corrigée
   - plus d'orderBy() côté serveur pour users => évite l'index composite
   - tri client côté navigateur
   - subscribe messages classes/{class}/messages limit(100)
   - scroll fixe
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
import {
  getFirestore, collection, doc, addDoc, serverTimestamp, query, orderBy, limit,
  onSnapshot, getDoc, getDocs, where
} from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyDYPGjiUNLU9nzPNWVDfWMXQ7zYeE7VRtI",
  authDomain: "laclassedefou.firebaseapp.com",
  projectId: "laclassedefou",
  storageBucket: "laclassedefou.firebasestorage.app",
  messagingSenderId: "625518146786",
  appId: "1:625518146786:web:1ccbf39c23199b0dda1abb",
  measurementId: "G-DP9HJXJGTC"
};
initializeApp(firebaseConfig);
const auth = getAuth();
const db = getFirestore();

const messagesEl = document.getElementById('messages');
const membersEl = document.getElementById('members');
const subEl = document.getElementById('sub');
const welcome = document.getElementById('welcome');
const composerWrap = document.getElementById('composerWrap');
const cantWrite = document.getElementById('cantWrite');
const textInput = document.getElementById('textInput');
const sendBtn = document.getElementById('sendBtn');

let myUid=null, myName='', isAdmin=false;
let classeParam = (new URLSearchParams(location.search)).get('class') || '';

const BLACKLIST = ['connard','merde','putain','sale','nique'];
function maskBadWords(s){
  return s.replace(/\p{L}+/gu, token => {
    const norm = token.normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
    return BLACKLIST.includes(norm) ? '#'.repeat(token.length) : token;
  });
}
function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"'`=\/]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;',"/":"&#x2F;", "`":"&#96;", "=":"&#61;'}[c])); }

function classMessagesRef(cls){ return collection(db,'classes', cls, 'messages'); }

// --- auth & main flow
onAuthStateChanged(auth, async user => {
  if(!user){ location.href='login.html'; return; }
  myUid = user.uid; myName = user.displayName || '';
  try{ const t = await user.getIdTokenResult(); isAdmin = !!(t.claims && t.claims.admin); }catch(e){}

  // if URL doesn't provide class, try user's doc
  if(!classeParam){
    try{
      const uSnap = await getDoc(doc(db,'users', myUid));
      if(uSnap.exists()) classeParam = uSnap.data().classe || '';
    }catch(e){ console.warn('cannot read users doc', e); }
  }
  if(!classeParam){ subEl.textContent = 'Aucune classe trouvée'; messagesEl.innerHTML = '<div class="meta">Impossible d\'afficher</div>'; membersEl.innerHTML='-'; return; }

  const displayClass = String(classeParam).toUpperCase();
  subEl.textContent = `Bienvenue dans le chat de ${displayClass}`;
  welcome.textContent = `Bienvenue dans le chat de ${displayClass}`;

  // --- LOAD MEMBERS (no orderBy to avoid index requirement) ---
  try{
    // query where classe == classeParam (no orderBy) then sort client-side by prenom
    const usersQuery = query(collection(db,'users'), where('classe','==', classeParam));
    const usersSnap = await getDocs(usersQuery);
    if(usersSnap.empty){
      membersEl.innerHTML = '<div class="meta">Aucun membre</div>';
    } else {
      // build array then sort by prenom (case-insensitive)
      const users = usersSnap.docs.map(d => ({ id: d.id, ...d.data() }));
      users.sort((a,b) => {
        const A = (a.prenom || '').toString().toLowerCase();
        const B = (b.prenom || '').toString().toLowerCase();
        if(A < B) return -1; if(A > B) return 1; return 0;
      });
      membersEl.innerHTML = '<ul style="padding-left:16px;margin:0">' + users.map(u => `<li>${escapeHtml((u.prenom || u.displayName || '') + ' ' + (u.nom || ''))}</li>`).join('') + '</ul>';
    }
  }catch(e){
    console.error('load members error', e);
    membersEl.innerHTML = '<div class="meta" style="color:#ffb4b4">Impossible de charger les membres (permissions)</div>';
  }

  // determine if user can chat (must be in same class or admin)
  let userClasse = '';
  try{
    const uSnap = await getDoc(doc(db,'users', myUid));
    if(uSnap.exists()) userClasse = (uSnap.data().classe||'').toString().toUpperCase();
  }catch(e){ console.warn('read user doc failed', e); }

  const canChat = isAdmin || (userClasse && userClasse === displayClass);
  if(!canChat){
    composerWrap.style.display = 'none';
    cantWrite.style.display = 'block';
    // try to subscribe read-only (if rules allow)
    try{
      const q = query(classMessagesRef(displayClass), orderBy('createdAt','desc'), limit(100));
      onSnapshot(q, snap => {
        messagesEl.innerHTML = '';
        const docs = snap.docs.slice().reverse();
        docs.forEach(d=>{
          const m = d.data();
          const who = m.displayName || m.prenom || m.email || 'Anonyme';
          const time = m.createdAt && m.createdAt.toDate ? new Date(m.createdAt.toDate()).toLocaleTimeString() : '';
          const el = document.createElement('div'); el.className='msg';
          el.innerHTML = `<div class="meta">${escapeHtml(who)} • ${escapeHtml(time)}</div><div>${escapeHtml(m.text)}</div>`;
          messagesEl.appendChild(el);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    }catch(e){ console.warn('subscribe read-only failed', e); messagesEl.innerHTML = '<div class="meta">Lecture non autorisée par les règles.</div>'; }
    return;
  }

  // can chat → show composer and subscribe
  composerWrap.style.display = 'flex';
  cantWrite.style.display = 'none';
  try{
    const q = query(classMessagesRef(displayClass), orderBy('createdAt','desc'), limit(100));
    onSnapshot(q, snap => {
      messagesEl.innerHTML = '';
      const docs = snap.docs.slice().reverse();
      docs.forEach(d=>{
        const m = d.data(); const who = m.displayName || m.prenom || m.email || 'Anonyme';
        const time = m.createdAt && m.createdAt.toDate ? new Date(m.createdAt.toDate()).toLocaleTimeString() : '';
        const el = document.createElement('div'); el.className='msg';
        el.innerHTML = `<div class="meta">${escapeHtml(who)} • ${escapeHtml(time)}</div><div>${escapeHtml(m.text)}</div>`;
        messagesEl.appendChild(el);
      });
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }, err => {
      console.error('subscribe class messages error', err);
      messagesEl.innerHTML = `<div class="meta" style="color:#ff9b9b">Erreur lecture : ${escapeHtml(err.message)}</div>`;
    });
  }catch(e){ console.error('subscribe error', e); }
});

// send message
async function sendMessage(){
  const raw = (textInput.value||'').trim();
  if(!raw) return;
  if(!classeParam){ alert('Classe introuvable'); return; }
  const user = auth.currentUser;
  if(!user){ alert('Reconnecte-toi'); return; }
  const text = maskBadWords(raw);
  try{
    await addDoc(collection(db,'classes', classeParam, 'messages'), {
      text,
      uid: user.uid,
      displayName: user.displayName || '',
      email: user.email || '',
      createdAt: serverTimestamp()
    });
    textInput.value = '';
  }catch(e){
    console.error('send error', e);
    alert('Erreur lors de l\'envoi : ' + (e.message || e));
  }
}

sendBtn.addEventListener('click', sendMessage);
textInput.addEventListener('keydown', e => { if(e.key === 'Enter') sendMessage(); });

</script>
</body>
</html>
